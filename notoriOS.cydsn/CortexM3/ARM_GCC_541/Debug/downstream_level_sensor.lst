ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"downstream_level_sensor.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.bss
  20              		.align	2
  21              	uart_chars:
  22 0000 00000000 		.space	257
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              	num_chars:
  24 0101 00       		.space	1
  25              		.data
  26              		.align	2
  27              		.type	line, %object
  28              		.size	line, 4
  29              	line:
  30 0000 00000000 		.word	uart_chars
  31              		.bss
  32 0102 0000     		.align	2
  33              	match:
  34 0104 00000000 		.space	4
  35              		.align	2
  36              	pattern:
  37 0108 00000000 		.space	4
  38              		.section	.text.Downstream_Level_Sensor_ISR,"ax",%progbits
  39              		.align	2
  40              		.global	Downstream_Level_Sensor_ISR
  41              		.thumb
  42              		.thumb_func
  43              		.type	Downstream_Level_Sensor_ISR, %function
  44              	Downstream_Level_Sensor_ISR:
  45              	.LFB64:
  46              		.file 1 "downstream_level_sensor.c"
   1:downstream_level_sensor.c **** #include "downstream_level_sensor.h"
   2:downstream_level_sensor.c **** 
   3:downstream_level_sensor.c **** // Circular buffer of recently received chars.
   4:downstream_level_sensor.c **** // Initialize all the members of the array uart_chars to 0. 
   5:downstream_level_sensor.c **** static char uart_chars[257] = {0};
   6:downstream_level_sensor.c **** static uint8_t num_chars = 0;
   7:downstream_level_sensor.c **** 
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 2


   8:downstream_level_sensor.c **** static const char *line = uart_chars;
   9:downstream_level_sensor.c **** // Only pointers can be null, where null is a special address used to signify that the pointer is n
  10:downstream_level_sensor.c **** // Pointers are not initialized to null by default, you must do so if you want them initialized.
  11:downstream_level_sensor.c **** static const char *match = NULL;
  12:downstream_level_sensor.c **** static const char *pattern = NULL;
  13:downstream_level_sensor.c **** 
  14:downstream_level_sensor.c **** // ISR: Interrupt Service Routine
  15:downstream_level_sensor.c **** CY_ISR(Downstream_Level_Sensor_ISR) {
  47              		.loc 1 15 0
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 8
  50              		@ frame_needed = 1, uses_anonymous_args = 0
  51 0000 80B5     		push	{r7, lr}
  52              		.cfi_def_cfa_offset 8
  53              		.cfi_offset 7, -8
  54              		.cfi_offset 14, -4
  55 0002 82B0     		sub	sp, sp, #8
  56              		.cfi_def_cfa_offset 16
  57 0004 00AF     		add	r7, sp, #0
  58              		.cfi_def_cfa_register 7
  16:downstream_level_sensor.c ****     /* Store received char in uart_chars.
  17:downstream_level_sensor.c ****     Returns the last received byte of data. Level_Sensor_UART_GetChar() is designed for ASCII chara
  18:downstream_level_sensor.c ****     1 to 255 are values for valid characters and 0 indicats an error occurred or no data is present
  19:downstream_level_sensor.c ****     char rx_char = Downstream_Level_Sensor_UART_GetChar();
  59              		.loc 1 19 0
  60 0006 FFF7FEFF 		bl	Downstream_Level_Sensor_UART_GetChar
  61 000a 0346     		mov	r3, r0
  62 000c FB71     		strb	r3, [r7, #7]
  20:downstream_level_sensor.c ****     // UART_GetChar() returns data, then set the entire uart_chars array to rx_char.
  21:downstream_level_sensor.c ****     if (rx_char) uart_chars[num_chars++] = rx_char;
  63              		.loc 1 21 0
  64 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  65 0010 002B     		cmp	r3, #0
  66 0012 09D0     		beq	.L2
  67              		.loc 1 21 0 is_stmt 0 discriminator 1
  68 0014 114B     		ldr	r3, .L5
  69 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  70 0018 5A1C     		adds	r2, r3, #1
  71 001a D1B2     		uxtb	r1, r2
  72 001c 0F4A     		ldr	r2, .L5
  73 001e 1170     		strb	r1, [r2]
  74 0020 1946     		mov	r1, r3
  75 0022 0F4A     		ldr	r2, .L5+4
  76 0024 FB79     		ldrb	r3, [r7, #7]
  77 0026 5354     		strb	r3, [r2, r1]
  78              	.L2:
  22:downstream_level_sensor.c **** 
  23:downstream_level_sensor.c ****     /* Check pattern at end of line */
  24:downstream_level_sensor.c ****     if (rx_char == '\r') {
  79              		.loc 1 24 0 is_stmt 1
  80 0028 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  81 002a 0D2B     		cmp	r3, #13
  82 002c 11D1     		bne	.L4
  25:downstream_level_sensor.c ****         // strstr(): char *strstr(const char *haystack, const char *needle). haystack - main C stri
  26:downstream_level_sensor.c ****         match = strstr(line, pattern);
  83              		.loc 1 26 0
  84 002e 0D4B     		ldr	r3, .L5+8
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 3


  85 0030 1A68     		ldr	r2, [r3]
  86 0032 0D4B     		ldr	r3, .L5+12
  87 0034 1B68     		ldr	r3, [r3]
  88 0036 1946     		mov	r1, r3
  89 0038 1046     		mov	r0, r2
  90 003a FFF7FEFF 		bl	strstr
  91 003e 0246     		mov	r2, r0
  92 0040 0A4B     		ldr	r3, .L5+16
  93 0042 1A60     		str	r2, [r3]
  27:downstream_level_sensor.c ****         line = uart_chars + num_chars;
  94              		.loc 1 27 0
  95 0044 054B     		ldr	r3, .L5
  96 0046 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  97 0048 1A46     		mov	r2, r3
  98 004a 054B     		ldr	r3, .L5+4
  99 004c 1344     		add	r3, r3, r2
 100 004e 054A     		ldr	r2, .L5+8
 101 0050 1360     		str	r3, [r2]
 102              	.L4:
  28:downstream_level_sensor.c ****     }
  29:downstream_level_sensor.c **** }
 103              		.loc 1 29 0
 104 0052 00BF     		nop
 105 0054 0837     		adds	r7, r7, #8
 106              		.cfi_def_cfa_offset 8
 107 0056 BD46     		mov	sp, r7
 108              		.cfi_def_cfa_register 13
 109              		@ sp needed
 110 0058 80BD     		pop	{r7, pc}
 111              	.L6:
 112 005a 00BF     		.align	2
 113              	.L5:
 114 005c 01010000 		.word	num_chars
 115 0060 00000000 		.word	uart_chars
 116 0064 00000000 		.word	line
 117 0068 08010000 		.word	pattern
 118 006c 04010000 		.word	match
 119              		.cfi_endproc
 120              	.LFE64:
 121              		.size	Downstream_Level_Sensor_ISR, .-Downstream_Level_Sensor_ISR
 122              		.section	.rodata
 123              		.align	2
 124              	.LC0:
 125 0000 5200     		.ascii	"R\000"
 126              		.section	.text.downstream_level_sensor_take_reading,"ax",%progbits
 127              		.align	2
 128              		.global	downstream_level_sensor_take_reading
 129              		.thumb
 130              		.thumb_func
 131              		.type	downstream_level_sensor_take_reading, %function
 132              	downstream_level_sensor_take_reading:
 133              	.LFB65:
  30:downstream_level_sensor.c **** 
  31:downstream_level_sensor.c **** // takes level sensor measurements and calculates average level sensor reading
  32:downstream_level_sensor.c **** level_sensor_t downstream_level_sensor_take_reading(){
 134              		.loc 1 32 0
 135              		.cfi_startproc
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 4


 136              		@ args = 0, pretend = 0, frame = 40
 137              		@ frame_needed = 1, uses_anonymous_args = 0
 138 0000 B0B5     		push	{r4, r5, r7, lr}
 139              		.cfi_def_cfa_offset 16
 140              		.cfi_offset 4, -16
 141              		.cfi_offset 5, -12
 142              		.cfi_offset 7, -8
 143              		.cfi_offset 14, -4
 144 0002 8AB0     		sub	sp, sp, #40
 145              		.cfi_def_cfa_offset 56
 146 0004 00AF     		add	r7, sp, #0
 147              		.cfi_def_cfa_register 7
 148 0006 7860     		str	r0, [r7, #4]
  33:downstream_level_sensor.c ****     
  34:downstream_level_sensor.c ****     // level_sensor_t is a new data type we defined in level_sensor.h. We then use that data type t
  35:downstream_level_sensor.c ****     level_sensor_t Downstream_Level_Sensor_output;
  36:downstream_level_sensor.c ****     Downstream_Level_Sensor_output.num_invalid_readings = 0;
 149              		.loc 1 36 0
 150 0008 0023     		movs	r3, #0
 151 000a 87F82130 		strb	r3, [r7, #33]
  37:downstream_level_sensor.c ****     Downstream_Level_Sensor_output.num_valid_readings = 0;
 152              		.loc 1 37 0
 153 000e 0023     		movs	r3, #0
 154 0010 87F82030 		strb	r3, [r7, #32]
  38:downstream_level_sensor.c ****     
  39:downstream_level_sensor.c ****     uart_clear();
 155              		.loc 1 39 0
 156 0014 FFF7FEFF 		bl	uart_clear
  40:downstream_level_sensor.c ****     
  41:downstream_level_sensor.c ****     // Start sensor power, uart, and isr
  42:downstream_level_sensor.c ****     Downstream_Level_Sensor_Power_Write(1u);   // Pulls Level Sensor power pin high (turns it on).
 157              		.loc 1 42 0
 158 0018 0120     		movs	r0, #1
 159 001a FFF7FEFF 		bl	Downstream_Level_Sensor_Power_Write
  43:downstream_level_sensor.c ****     CyDelay(200u); // Sensor bootup sequence ~200ms -- senosor will spit out ID info, but we don't 
 160              		.loc 1 43 0
 161 001e C820     		movs	r0, #200
 162 0020 FFF7FEFF 		bl	CyDelay
  44:downstream_level_sensor.c ****     Downstream_Level_Sensor_RX_SetDriveMode(PIN_DM_DIG_HIZ); // RX_SetDriveMode(): Sets the drive m
 163              		.loc 1 44 0
 164 0024 0220     		movs	r0, #2
 165 0026 FFF7FEFF 		bl	Downstream_Level_Sensor_RX_SetDriveMode
  45:downstream_level_sensor.c ****     Downstream_Level_Sensor_UART_Start(); // Downstream_Level_Sensor_UART_Start() sets the initVar 
 166              		.loc 1 45 0
 167 002a FFF7FEFF 		bl	Downstream_Level_Sensor_UART_Start
  46:downstream_level_sensor.c ****     Downstream_Level_Sensor_ISR_StartEx(Downstream_Level_Sensor_ISR); // Sets up the interrupt and 
 168              		.loc 1 46 0
 169 002e 3848     		ldr	r0, .L16
 170 0030 FFF7FEFF 		bl	Downstream_Level_Sensor_ISR_StartEx
  47:downstream_level_sensor.c ****     
  48:downstream_level_sensor.c ****     // Wait to take  reading
  49:downstream_level_sensor.c ****     // Sensor will take ~200ms to send first reading, and 200ms for subsequent readings
  50:downstream_level_sensor.c ****     CyDelay(2000u); // Take a few seconds to get readings, 2 secs ~10 readings
 171              		.loc 1 50 0
 172 0034 4FF4FA60 		mov	r0, #2000
 173 0038 FFF7FEFF 		bl	CyDelay
  51:downstream_level_sensor.c ****     
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 5


  52:downstream_level_sensor.c ****     //stop all sensor processes
  53:downstream_level_sensor.c ****     Downstream_Level_Sensor_UART_Stop(); // Disables the UART operation.
 174              		.loc 1 53 0
 175 003c FFF7FEFF 		bl	Downstream_Level_Sensor_UART_Stop
  54:downstream_level_sensor.c ****     Downstream_Level_Sensor_ISR_Stop(); // Disables and removes the interrupt.
 176              		.loc 1 54 0
 177 0040 FFF7FEFF 		bl	Downstream_Level_Sensor_ISR_Stop
  55:downstream_level_sensor.c ****     Downstream_Level_Sensor_Power_Write(0u); // Pulls Level Sensor Power pin low (turns it off).
 178              		.loc 1 55 0
 179 0044 0020     		movs	r0, #0
 180 0046 FFF7FEFF 		bl	Downstream_Level_Sensor_Power_Write
  56:downstream_level_sensor.c ****     // RX_SetDriveMode(): Sets the drive mode for each of the Pins component's pins.
  57:downstream_level_sensor.c ****     // String Drive Mode means it will only be outputting a voltage (don't send any data) when pull
  58:downstream_level_sensor.c ****     // UART in PSOC starts high. Then pulls low to get data. When turn sensor off, still using powe
  59:downstream_level_sensor.c ****     // So turning it to Strong Drive has it stay low.
  60:downstream_level_sensor.c ****     Downstream_Level_Sensor_RX_SetDriveMode(PIN_DM_STRONG);
 181              		.loc 1 60 0
 182 004a 0C20     		movs	r0, #12
 183 004c FFF7FEFF 		bl	Downstream_Level_Sensor_RX_SetDriveMode
  61:downstream_level_sensor.c ****     // Stops writing the value to the physical port.
  62:downstream_level_sensor.c ****     // Just because turn power of sensor off, pin could still be high and getting power. This ensur
  63:downstream_level_sensor.c ****     Downstream_Level_Sensor_RX_Write(0u);
 184              		.loc 1 63 0
 185 0050 0020     		movs	r0, #0
 186 0052 FFF7FEFF 		bl	Downstream_Level_Sensor_RX_Write
  64:downstream_level_sensor.c **** 
  65:downstream_level_sensor.c ****     /* Return parsed reading */
  66:downstream_level_sensor.c ****     // Parse string and put all values into array
  67:downstream_level_sensor.c ****     // The sensor will power on and do a few things, after which the readigs will follow with the s
  68:downstream_level_sensor.c ****     // Readings are stashed between "R" and "\000"
  69:downstream_level_sensor.c ****     char *token;
  70:downstream_level_sensor.c ****     // strtok(): breaks uart_chars into smaller string when sees "R".
  71:downstream_level_sensor.c ****     token = strtok(uart_chars, "R");
 187              		.loc 1 71 0
 188 0056 2F49     		ldr	r1, .L16+4
 189 0058 2F48     		ldr	r0, .L16+8
 190 005a FFF7FEFF 		bl	strtok
 191 005e 7862     		str	r0, [r7, #36]
  72:downstream_level_sensor.c ****     /* walk through other tokens */
  73:downstream_level_sensor.c ****    while( token != NULL ) 
 192              		.loc 1 73 0
 193 0060 33E0     		b	.L8
 194              	.L13:
  74:downstream_level_sensor.c ****    {
  75:downstream_level_sensor.c ****       if(strstr(token, "\r") != NULL){ // Full reading is delimieted by "R" + reading + "\r"
 195              		.loc 1 75 0
 196 0062 0D21     		movs	r1, #13
 197 0064 786A     		ldr	r0, [r7, #36]
 198 0066 FFF7FEFF 		bl	strchr
 199 006a 0346     		mov	r3, r0
 200 006c 002B     		cmp	r3, #0
 201 006e 27D0     		beq	.L9
 202              	.LBB2:
  76:downstream_level_sensor.c ****         // int atoi(const char *str) converts the string argument str to an integer (type int).
  77:downstream_level_sensor.c ****         uint16 reading = atoi(token);
 203              		.loc 1 77 0
 204 0070 786A     		ldr	r0, [r7, #36]
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 6


 205 0072 FFF7FEFF 		bl	atoi
 206 0076 0346     		mov	r3, r0
 207 0078 7B84     		strh	r3, [r7, #34]	@ movhi
  78:downstream_level_sensor.c ****         if(reading != 0){
 208              		.loc 1 78 0
 209 007a 7B8C     		ldrh	r3, [r7, #34]
 210 007c 002B     		cmp	r3, #0
 211 007e 1FD0     		beq	.L9
  79:downstream_level_sensor.c ****             if(reading != READING_INVALID){ // Invald readings by maxbotix
 212              		.loc 1 79 0
 213 0080 7B8C     		ldrh	r3, [r7, #34]
 214 0082 42F20F72 		movw	r2, #9999
 215 0086 9342     		cmp	r3, r2
 216 0088 14D0     		beq	.L10
  80:downstream_level_sensor.c ****                 // Set the level readings array of the length of number of valid readings equal to 
  81:downstream_level_sensor.c ****                 Downstream_Level_Sensor_output.all_level_readings[Downstream_Level_Sensor_output.nu
 217              		.loc 1 81 0
 218 008a 97F82030 		ldrb	r3, [r7, #32]	@ zero_extendqisi2
 219 008e B7F92220 		ldrsh	r2, [r7, #34]
 220 0092 5B00     		lsls	r3, r3, #1
 221 0094 07F12801 		add	r1, r7, #40
 222 0098 0B44     		add	r3, r3, r1
 223 009a 23F8202C 		strh	r2, [r3, #-32]	@ movhi
  82:downstream_level_sensor.c ****                 // If number of valid readings less than 11 total readings, increase the count of v
  83:downstream_level_sensor.c ****                 if(Downstream_Level_Sensor_output.num_valid_readings < N_READINGS){
 224              		.loc 1 83 0
 225 009e 97F82030 		ldrb	r3, [r7, #32]	@ zero_extendqisi2
 226 00a2 0A2B     		cmp	r3, #10
 227 00a4 15D8     		bhi	.L15
  84:downstream_level_sensor.c ****                     Downstream_Level_Sensor_output.num_valid_readings++;
 228              		.loc 1 84 0
 229 00a6 97F82030 		ldrb	r3, [r7, #32]	@ zero_extendqisi2
 230 00aa 0133     		adds	r3, r3, #1
 231 00ac DBB2     		uxtb	r3, r3
 232 00ae 87F82030 		strb	r3, [r7, #32]
 233 00b2 05E0     		b	.L9
 234              	.L10:
  85:downstream_level_sensor.c ****                 }else{
  86:downstream_level_sensor.c ****                  break;   
  87:downstream_level_sensor.c ****                 }
  88:downstream_level_sensor.c ****                 
  89:downstream_level_sensor.c ****             }else{
  90:downstream_level_sensor.c ****                 // Otherwise increase the count of invalid readings
  91:downstream_level_sensor.c ****                 Downstream_Level_Sensor_output.num_invalid_readings++;
 235              		.loc 1 91 0
 236 00b4 97F82130 		ldrb	r3, [r7, #33]	@ zero_extendqisi2
 237 00b8 0133     		adds	r3, r3, #1
 238 00ba DBB2     		uxtb	r3, r3
 239 00bc 87F82130 		strb	r3, [r7, #33]
 240              	.L9:
 241              	.LBE2:
  92:downstream_level_sensor.c ****             }
  93:downstream_level_sensor.c ****         }
  94:downstream_level_sensor.c ****       }
  95:downstream_level_sensor.c ****       token = strtok(NULL, "R"); // This "NULL" says to continue where you left off last time.
 242              		.loc 1 95 0
 243 00c0 1449     		ldr	r1, .L16+4
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 7


 244 00c2 0020     		movs	r0, #0
 245 00c4 FFF7FEFF 		bl	strtok
 246 00c8 7862     		str	r0, [r7, #36]
 247              	.L8:
  73:downstream_level_sensor.c ****    {
 248              		.loc 1 73 0
 249 00ca 7B6A     		ldr	r3, [r7, #36]
 250 00cc 002B     		cmp	r3, #0
 251 00ce C8D1     		bne	.L13
 252 00d0 00E0     		b	.L12
 253              	.L15:
 254              	.LBB3:
  86:downstream_level_sensor.c ****                 }
 255              		.loc 1 86 0
 256 00d2 00BF     		nop
 257              	.L12:
 258              	.LBE3:
  96:downstream_level_sensor.c ****    }
  97:downstream_level_sensor.c ****     // Calculate median level reading
  98:downstream_level_sensor.c ****     Downstream_Level_Sensor_output.level_reading = find_median(Downstream_Level_Sensor_output.all_l
 259              		.loc 1 98 0
 260 00d4 97F82020 		ldrb	r2, [r7, #32]	@ zero_extendqisi2
 261 00d8 07F10803 		add	r3, r7, #8
 262 00dc 1146     		mov	r1, r2
 263 00de 1846     		mov	r0, r3
 264 00e0 FFF7FEFF 		bl	find_median
 265 00e4 0346     		mov	r3, r0
 266 00e6 1BB2     		sxth	r3, r3
 267 00e8 FB83     		strh	r3, [r7, #30]	@ movhi
  99:downstream_level_sensor.c ****     
 100:downstream_level_sensor.c ****     return Downstream_Level_Sensor_output;
 268              		.loc 1 100 0
 269 00ea 7B68     		ldr	r3, [r7, #4]
 270 00ec 1D46     		mov	r5, r3
 271 00ee 07F10804 		add	r4, r7, #8
 272 00f2 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 273 00f4 2860     		str	r0, [r5]	@ unaligned
 274 00f6 6960     		str	r1, [r5, #4]	@ unaligned
 275 00f8 AA60     		str	r2, [r5, #8]	@ unaligned
 276 00fa EB60     		str	r3, [r5, #12]	@ unaligned
 277 00fc 03CC     		ldmia	r4!, {r0, r1}
 278 00fe 2861     		str	r0, [r5, #16]	@ unaligned
 279 0100 6961     		str	r1, [r5, #20]	@ unaligned
 280 0102 2388     		ldrh	r3, [r4]	@ unaligned
 281 0104 2B83     		strh	r3, [r5, #24]	@ unaligned
 101:downstream_level_sensor.c **** }
 282              		.loc 1 101 0
 283 0106 7868     		ldr	r0, [r7, #4]
 284 0108 2837     		adds	r7, r7, #40
 285              		.cfi_def_cfa_offset 16
 286 010a BD46     		mov	sp, r7
 287              		.cfi_def_cfa_register 13
 288              		@ sp needed
 289 010c B0BD     		pop	{r4, r5, r7, pc}
 290              	.L17:
 291 010e 00BF     		.align	2
 292              	.L16:
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 8


 293 0110 00000000 		.word	Downstream_Level_Sensor_ISR
 294 0114 00000000 		.word	.LC0
 295 0118 00000000 		.word	uart_chars
 296              		.cfi_endproc
 297              	.LFE65:
 298              		.size	downstream_level_sensor_take_reading, .-downstream_level_sensor_take_reading
 299              		.section	.rodata
 300 0002 0000     		.align	2
 301              	.LC1:
 302 0004 54455354 		.ascii	"TEST_DOWNSTREAM_LEVEL_SENSOR\000"
 302      5F444F57 
 302      4E535452 
 302      45414D5F 
 302      4C455645 
 303 0021 000000   		.align	2
 304              	.LC2:
 305 0024 6E57414E 		.ascii	"nWANTED=%d,nRECEIVED=%d,nVALID=%d,nMEDIAN=%d.\000"
 305      5445443D 
 305      25642C6E 
 305      52454345 
 305      49564544 
 306              		.section	.text.downstream_level_sensor_test,"ax",%progbits
 307              		.align	2
 308              		.global	downstream_level_sensor_test
 309              		.thumb
 310              		.thumb_func
 311              		.type	downstream_level_sensor_test, %function
 312              	downstream_level_sensor_test:
 313              	.LFB66:
 102:downstream_level_sensor.c **** 
 103:downstream_level_sensor.c **** // Level sensor test
 104:downstream_level_sensor.c **** test_t downstream_level_sensor_test(){
 314              		.loc 1 104 0
 315              		.cfi_startproc
 316              		@ args = 0, pretend = 0, frame = 424
 317              		@ frame_needed = 1, uses_anonymous_args = 0
 318 0000 B0B5     		push	{r4, r5, r7, lr}
 319              		.cfi_def_cfa_offset 16
 320              		.cfi_offset 4, -16
 321              		.cfi_offset 5, -12
 322              		.cfi_offset 7, -8
 323              		.cfi_offset 14, -4
 324 0002 EEB0     		sub	sp, sp, #440
 325              		.cfi_def_cfa_offset 456
 326 0004 04AF     		add	r7, sp, #16
 327              		.cfi_def_cfa 7, 440
 328 0006 3B1D     		adds	r3, r7, #4
 329 0008 1860     		str	r0, [r3]
 105:downstream_level_sensor.c ****     
 106:downstream_level_sensor.c ****     test_t test; // test_t is a new data type we defined in test.h. We then use that data type to d
 107:downstream_level_sensor.c ****     test.status = 0; // set test status to zero
 330              		.loc 1 107 0
 331 000a 07F12403 		add	r3, r7, #36
 332 000e 0022     		movs	r2, #0
 333 0010 83F88020 		strb	r2, [r3, #128]
 108:downstream_level_sensor.c ****     snprintf(test.test_name,sizeof(test.test_name),"TEST_DOWNSTREAM_LEVEL_SENSOR");
 334              		.loc 1 108 0
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 9


 335 0014 07F12403 		add	r3, r7, #36
 336 0018 2B4A     		ldr	r2, .L22
 337 001a 1C46     		mov	r4, r3
 338 001c 1546     		mov	r5, r2
 339 001e 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 340 0020 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 341 0022 95E80F00 		ldmia	r5, {r0, r1, r2, r3}
 342 0026 07C4     		stmia	r4!, {r0, r1, r2}
 343 0028 2370     		strb	r3, [r4]
 109:downstream_level_sensor.c **** 
 110:downstream_level_sensor.c ****     // level_sensor_t is a new data type we defined in level_sensor.h. We then use that data type t
 111:downstream_level_sensor.c ****     level_sensor_t sensor = downstream_level_sensor_take_reading();
 344              		.loc 1 111 0
 345 002a 07F10803 		add	r3, r7, #8
 346 002e 1846     		mov	r0, r3
 347 0030 FFF7FEFF 		bl	downstream_level_sensor_take_reading
 112:downstream_level_sensor.c ****     
 113:downstream_level_sensor.c ****     // print the max number of readings (11), the number of actual readings, the number of valid re
 114:downstream_level_sensor.c ****     snprintf(test.reason,sizeof(test.reason),"nWANTED=%d,nRECEIVED=%d,nVALID=%d,nMEDIAN=%d.",
 115:downstream_level_sensor.c ****         N_READINGS,
 116:downstream_level_sensor.c ****         sensor.num_valid_readings+sensor.num_invalid_readings,
 348              		.loc 1 116 0
 349 0034 07F10803 		add	r3, r7, #8
 350 0038 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 114:downstream_level_sensor.c ****         N_READINGS,
 351              		.loc 1 114 0
 352 003a 1A46     		mov	r2, r3
 353              		.loc 1 116 0
 354 003c 07F10803 		add	r3, r7, #8
 355 0040 5B7E     		ldrb	r3, [r3, #25]	@ zero_extendqisi2
 114:downstream_level_sensor.c ****         N_READINGS,
 356              		.loc 1 114 0
 357 0042 1344     		add	r3, r3, r2
 117:downstream_level_sensor.c ****         sensor.num_valid_readings,
 358              		.loc 1 117 0
 359 0044 07F10802 		add	r2, r7, #8
 360 0048 127E     		ldrb	r2, [r2, #24]	@ zero_extendqisi2
 114:downstream_level_sensor.c ****         N_READINGS,
 361              		.loc 1 114 0
 362 004a 1146     		mov	r1, r2
 118:downstream_level_sensor.c ****         sensor.level_reading
 363              		.loc 1 118 0
 364 004c 07F10802 		add	r2, r7, #8
 365 0050 B2F91620 		ldrsh	r2, [r2, #22]
 114:downstream_level_sensor.c ****         N_READINGS,
 366              		.loc 1 114 0
 367 0054 1446     		mov	r4, r2
 368 0056 07F12402 		add	r2, r7, #36
 369 005a 02F18100 		add	r0, r2, #129
 370 005e 0294     		str	r4, [sp, #8]
 371 0060 0191     		str	r1, [sp, #4]
 372 0062 0093     		str	r3, [sp]
 373 0064 0B23     		movs	r3, #11
 374 0066 194A     		ldr	r2, .L22+4
 375 0068 4FF48071 		mov	r1, #256
 376 006c FFF7FEFF 		bl	snprintf
 119:downstream_level_sensor.c ****     );
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 10


 120:downstream_level_sensor.c ****    
 121:downstream_level_sensor.c ****     // if the number valid readings is the max number of readings (11), then the test passes with t
 122:downstream_level_sensor.c ****     if(sensor.num_valid_readings == N_READINGS){//pass
 377              		.loc 1 122 0
 378 0070 07F10803 		add	r3, r7, #8
 379 0074 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 380 0076 0B2B     		cmp	r3, #11
 381 0078 05D1     		bne	.L19
 123:downstream_level_sensor.c ****         test.status = 1;
 382              		.loc 1 123 0
 383 007a 07F12403 		add	r3, r7, #36
 384 007e 0122     		movs	r2, #1
 385 0080 83F88020 		strb	r2, [r3, #128]
 386 0084 0EE0     		b	.L20
 387              	.L19:
 124:downstream_level_sensor.c ****     // if the number of valid readings is greater than zero and less than the max number of reading
 125:downstream_level_sensor.c ****     }else if((sensor.num_valid_readings > 0) && (sensor.num_valid_readings < N_READINGS)){//pass
 388              		.loc 1 125 0
 389 0086 07F10803 		add	r3, r7, #8
 390 008a 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 391 008c 002B     		cmp	r3, #0
 392 008e 09D0     		beq	.L20
 393              		.loc 1 125 0 is_stmt 0 discriminator 1
 394 0090 07F10803 		add	r3, r7, #8
 395 0094 1B7E     		ldrb	r3, [r3, #24]	@ zero_extendqisi2
 396 0096 0A2B     		cmp	r3, #10
 397 0098 04D8     		bhi	.L20
 126:downstream_level_sensor.c ****         test.status = 2; //not bad, since we got some OK readings
 398              		.loc 1 126 0 is_stmt 1
 399 009a 07F12403 		add	r3, r7, #36
 400 009e 0222     		movs	r2, #2
 401 00a0 83F88020 		strb	r2, [r3, #128]
 402              	.L20:
 127:downstream_level_sensor.c ****     }
 128:downstream_level_sensor.c ****         
 129:downstream_level_sensor.c ****     return test;
 403              		.loc 1 129 0
 404 00a4 3B1D     		adds	r3, r7, #4
 405 00a6 1A68     		ldr	r2, [r3]
 406 00a8 07F12403 		add	r3, r7, #36
 407 00ac 1046     		mov	r0, r2
 408 00ae 1946     		mov	r1, r3
 409 00b0 40F28113 		movw	r3, #385
 410 00b4 1A46     		mov	r2, r3
 411 00b6 FFF7FEFF 		bl	memcpy
 130:downstream_level_sensor.c **** }
 412              		.loc 1 130 0
 413 00ba 3B1D     		adds	r3, r7, #4
 414 00bc 1868     		ldr	r0, [r3]
 415 00be 07F5D477 		add	r7, r7, #424
 416              		.cfi_def_cfa_offset 16
 417 00c2 BD46     		mov	sp, r7
 418              		.cfi_def_cfa_register 13
 419              		@ sp needed
 420 00c4 B0BD     		pop	{r4, r5, r7, pc}
 421              	.L23:
 422 00c6 00BF     		.align	2
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 11


 423              	.L22:
 424 00c8 04000000 		.word	.LC1
 425 00cc 24000000 		.word	.LC2
 426              		.cfi_endproc
 427              	.LFE66:
 428              		.size	downstream_level_sensor_test, .-downstream_level_sensor_test
 429              		.text
 430              	.Letext0:
 431              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 432              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 433              		.file 4 "Generated_Source\\PSoC5/cytypes.h"
 434              		.file 5 "testing.h"
 435              		.file 6 "level_sensor.h"
 436              		.file 7 "Generated_Source\\PSoC5/core_cm3.h"
 437              		.section	.debug_info,"",%progbits
 438              	.Ldebug_info0:
 439 0000 B6020000 		.4byte	0x2b6
 440 0004 0400     		.2byte	0x4
 441 0006 00000000 		.4byte	.Ldebug_abbrev0
 442 000a 04       		.byte	0x4
 443 000b 01       		.uleb128 0x1
 444 000c 0A000000 		.4byte	.LASF44
 445 0010 0C       		.byte	0xc
 446 0011 A9020000 		.4byte	.LASF45
 447 0015 A6010000 		.4byte	.LASF46
 448 0019 18000000 		.4byte	.Ldebug_ranges0+0x18
 449 001d 00000000 		.4byte	0
 450 0021 00000000 		.4byte	.Ldebug_line0
 451 0025 02       		.uleb128 0x2
 452 0026 01       		.byte	0x1
 453 0027 06       		.byte	0x6
 454 0028 EC020000 		.4byte	.LASF0
 455 002c 03       		.uleb128 0x3
 456 002d 00000000 		.4byte	.LASF4
 457 0031 02       		.byte	0x2
 458 0032 1D       		.byte	0x1d
 459 0033 37000000 		.4byte	0x37
 460 0037 02       		.uleb128 0x2
 461 0038 01       		.byte	0x1
 462 0039 08       		.byte	0x8
 463 003a 15010000 		.4byte	.LASF1
 464 003e 02       		.uleb128 0x2
 465 003f 02       		.byte	0x2
 466 0040 05       		.byte	0x5
 467 0041 DE010000 		.4byte	.LASF2
 468 0045 02       		.uleb128 0x2
 469 0046 02       		.byte	0x2
 470 0047 07       		.byte	0x7
 471 0048 5D010000 		.4byte	.LASF3
 472 004c 03       		.uleb128 0x3
 473 004d 98000000 		.4byte	.LASF5
 474 0051 02       		.byte	0x2
 475 0052 3F       		.byte	0x3f
 476 0053 57000000 		.4byte	0x57
 477 0057 02       		.uleb128 0x2
 478 0058 04       		.byte	0x4
 479 0059 05       		.byte	0x5
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 12


 480 005a A9000000 		.4byte	.LASF6
 481 005e 02       		.uleb128 0x2
 482 005f 04       		.byte	0x4
 483 0060 07       		.byte	0x7
 484 0061 4B010000 		.4byte	.LASF7
 485 0065 02       		.uleb128 0x2
 486 0066 08       		.byte	0x8
 487 0067 05       		.byte	0x5
 488 0068 72020000 		.4byte	.LASF8
 489 006c 02       		.uleb128 0x2
 490 006d 08       		.byte	0x8
 491 006e 07       		.byte	0x7
 492 006f 0F020000 		.4byte	.LASF9
 493 0073 04       		.uleb128 0x4
 494 0074 04       		.byte	0x4
 495 0075 05       		.byte	0x5
 496 0076 696E7400 		.ascii	"int\000"
 497 007a 02       		.uleb128 0x2
 498 007b 04       		.byte	0x4
 499 007c 07       		.byte	0x7
 500 007d 02020000 		.4byte	.LASF10
 501 0081 03       		.uleb128 0x3
 502 0082 26020000 		.4byte	.LASF11
 503 0086 03       		.byte	0x3
 504 0087 18       		.byte	0x18
 505 0088 2C000000 		.4byte	0x2c
 506 008c 03       		.uleb128 0x3
 507 008d 3A020000 		.4byte	.LASF12
 508 0091 03       		.byte	0x3
 509 0092 2C       		.byte	0x2c
 510 0093 4C000000 		.4byte	0x4c
 511 0097 02       		.uleb128 0x2
 512 0098 08       		.byte	0x8
 513 0099 04       		.byte	0x4
 514 009a E0020000 		.4byte	.LASF13
 515 009e 02       		.uleb128 0x2
 516 009f 04       		.byte	0x4
 517 00a0 07       		.byte	0x7
 518 00a1 42020000 		.4byte	.LASF14
 519 00a5 05       		.uleb128 0x5
 520 00a6 04       		.byte	0x4
 521 00a7 AB000000 		.4byte	0xab
 522 00ab 02       		.uleb128 0x2
 523 00ac 01       		.byte	0x1
 524 00ad 08       		.byte	0x8
 525 00ae 80020000 		.4byte	.LASF15
 526 00b2 05       		.uleb128 0x5
 527 00b3 04       		.byte	0x4
 528 00b4 B8000000 		.4byte	0xb8
 529 00b8 06       		.uleb128 0x6
 530 00b9 AB000000 		.4byte	0xab
 531 00bd 02       		.uleb128 0x2
 532 00be 08       		.byte	0x8
 533 00bf 04       		.byte	0x4
 534 00c0 9F010000 		.4byte	.LASF16
 535 00c4 02       		.uleb128 0x2
 536 00c5 04       		.byte	0x4
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 13


 537 00c6 04       		.byte	0x4
 538 00c7 0F010000 		.4byte	.LASF17
 539 00cb 07       		.uleb128 0x7
 540 00cc C3020000 		.4byte	.LASF18
 541 00d0 04       		.byte	0x4
 542 00d1 9201     		.2byte	0x192
 543 00d3 37000000 		.4byte	0x37
 544 00d7 07       		.uleb128 0x7
 545 00d8 F6010000 		.4byte	.LASF19
 546 00dc 04       		.byte	0x4
 547 00dd 9301     		.2byte	0x193
 548 00df 45000000 		.4byte	0x45
 549 00e3 07       		.uleb128 0x7
 550 00e4 45010000 		.4byte	.LASF20
 551 00e8 04       		.byte	0x4
 552 00e9 9601     		.2byte	0x196
 553 00eb 3E000000 		.4byte	0x3e
 554 00ef 08       		.uleb128 0x8
 555 00f0 8101     		.2byte	0x181
 556 00f2 05       		.byte	0x5
 557 00f3 0A       		.byte	0xa
 558 00f4 1D010000 		.4byte	0x11d
 559 00f8 09       		.uleb128 0x9
 560 00f9 C9020000 		.4byte	.LASF21
 561 00fd 05       		.byte	0x5
 562 00fe 0C       		.byte	0xc
 563 00ff 1D010000 		.4byte	0x11d
 564 0103 00       		.byte	0
 565 0104 09       		.uleb128 0x9
 566 0105 D9020000 		.4byte	.LASF22
 567 0109 05       		.byte	0x5
 568 010a 0D       		.byte	0xd
 569 010b CB000000 		.4byte	0xcb
 570 010f 80       		.byte	0x80
 571 0110 09       		.uleb128 0x9
 572 0111 33020000 		.4byte	.LASF23
 573 0115 05       		.byte	0x5
 574 0116 0F       		.byte	0xf
 575 0117 2D010000 		.4byte	0x12d
 576 011b 81       		.byte	0x81
 577 011c 00       		.byte	0
 578 011d 0A       		.uleb128 0xa
 579 011e AB000000 		.4byte	0xab
 580 0122 2D010000 		.4byte	0x12d
 581 0126 0B       		.uleb128 0xb
 582 0127 9E000000 		.4byte	0x9e
 583 012b 7F       		.byte	0x7f
 584 012c 00       		.byte	0
 585 012d 0A       		.uleb128 0xa
 586 012e AB000000 		.4byte	0xab
 587 0132 3D010000 		.4byte	0x13d
 588 0136 0B       		.uleb128 0xb
 589 0137 9E000000 		.4byte	0x9e
 590 013b FF       		.byte	0xff
 591 013c 00       		.byte	0
 592 013d 03       		.uleb128 0x3
 593 013e A2000000 		.4byte	.LASF24
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 14


 594 0142 05       		.byte	0x5
 595 0143 10       		.byte	0x10
 596 0144 EF000000 		.4byte	0xef
 597 0148 0C       		.uleb128 0xc
 598 0149 1A       		.byte	0x1a
 599 014a 06       		.byte	0x6
 600 014b 10       		.byte	0x10
 601 014c 81010000 		.4byte	0x181
 602 0150 09       		.uleb128 0x9
 603 0151 B2000000 		.4byte	.LASF25
 604 0155 06       		.byte	0x6
 605 0156 11       		.byte	0x11
 606 0157 81010000 		.4byte	0x181
 607 015b 00       		.byte	0
 608 015c 09       		.uleb128 0x9
 609 015d E8010000 		.4byte	.LASF26
 610 0161 06       		.byte	0x6
 611 0162 12       		.byte	0x12
 612 0163 E3000000 		.4byte	0xe3
 613 0167 16       		.byte	0x16
 614 0168 09       		.uleb128 0x9
 615 0169 C5000000 		.4byte	.LASF27
 616 016d 06       		.byte	0x6
 617 016e 13       		.byte	0x13
 618 016f CB000000 		.4byte	0xcb
 619 0173 18       		.byte	0x18
 620 0174 09       		.uleb128 0x9
 621 0175 F8020000 		.4byte	.LASF28
 622 0179 06       		.byte	0x6
 623 017a 14       		.byte	0x14
 624 017b CB000000 		.4byte	0xcb
 625 017f 19       		.byte	0x19
 626 0180 00       		.byte	0
 627 0181 0A       		.uleb128 0xa
 628 0182 E3000000 		.4byte	0xe3
 629 0186 91010000 		.4byte	0x191
 630 018a 0B       		.uleb128 0xb
 631 018b 9E000000 		.4byte	0x9e
 632 018f 0A       		.byte	0xa
 633 0190 00       		.byte	0
 634 0191 03       		.uleb128 0x3
 635 0192 70010000 		.4byte	.LASF29
 636 0196 06       		.byte	0x6
 637 0197 15       		.byte	0x15
 638 0198 48010000 		.4byte	0x148
 639 019c 0D       		.uleb128 0xd
 640 019d 29010000 		.4byte	.LASF30
 641 01a1 01       		.byte	0x1
 642 01a2 0F       		.byte	0xf
 643 01a3 00000000 		.4byte	.LFB64
 644 01a7 70000000 		.4byte	.LFE64-.LFB64
 645 01ab 01       		.uleb128 0x1
 646 01ac 9C       		.byte	0x9c
 647 01ad C0010000 		.4byte	0x1c0
 648 01b1 0E       		.uleb128 0xe
 649 01b2 8A010000 		.4byte	.LASF32
 650 01b6 01       		.byte	0x1
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 15


 651 01b7 13       		.byte	0x13
 652 01b8 AB000000 		.4byte	0xab
 653 01bc 02       		.uleb128 0x2
 654 01bd 91       		.byte	0x91
 655 01be 77       		.sleb128 -9
 656 01bf 00       		.byte	0
 657 01c0 0F       		.uleb128 0xf
 658 01c1 D8000000 		.4byte	.LASF31
 659 01c5 01       		.byte	0x1
 660 01c6 20       		.byte	0x20
 661 01c7 91010000 		.4byte	0x191
 662 01cb 00000000 		.4byte	.LFB65
 663 01cf 1C010000 		.4byte	.LFE65-.LFB65
 664 01d3 01       		.uleb128 0x1
 665 01d4 9C       		.byte	0x9c
 666 01d5 0A020000 		.4byte	0x20a
 667 01d9 0E       		.uleb128 0xe
 668 01da 4B020000 		.4byte	.LASF33
 669 01de 01       		.byte	0x1
 670 01df 23       		.byte	0x23
 671 01e0 91010000 		.4byte	0x191
 672 01e4 02       		.uleb128 0x2
 673 01e5 91       		.byte	0x91
 674 01e6 50       		.sleb128 -48
 675 01e7 0E       		.uleb128 0xe
 676 01e8 D3020000 		.4byte	.LASF34
 677 01ec 01       		.byte	0x1
 678 01ed 45       		.byte	0x45
 679 01ee A5000000 		.4byte	0xa5
 680 01f2 02       		.uleb128 0x2
 681 01f3 91       		.byte	0x91
 682 01f4 6C       		.sleb128 -20
 683 01f5 10       		.uleb128 0x10
 684 01f6 00000000 		.4byte	.Ldebug_ranges0+0
 685 01fa 0E       		.uleb128 0xe
 686 01fb 07010000 		.4byte	.LASF35
 687 01ff 01       		.byte	0x1
 688 0200 4D       		.byte	0x4d
 689 0201 D7000000 		.4byte	0xd7
 690 0205 02       		.uleb128 0x2
 691 0206 91       		.byte	0x91
 692 0207 6A       		.sleb128 -22
 693 0208 00       		.byte	0
 694 0209 00       		.byte	0
 695 020a 0F       		.uleb128 0xf
 696 020b 8C020000 		.4byte	.LASF36
 697 020f 01       		.byte	0x1
 698 0210 68       		.byte	0x68
 699 0211 3D010000 		.4byte	0x13d
 700 0215 00000000 		.4byte	.LFB66
 701 0219 D0000000 		.4byte	.LFE66-.LFB66
 702 021d 01       		.uleb128 0x1
 703 021e 9C       		.byte	0x9c
 704 021f 42020000 		.4byte	0x242
 705 0223 0E       		.uleb128 0xe
 706 0224 FD010000 		.4byte	.LASF37
 707 0228 01       		.byte	0x1
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 16


 708 0229 6A       		.byte	0x6a
 709 022a 3D010000 		.4byte	0x13d
 710 022e 03       		.uleb128 0x3
 711 022f 91       		.byte	0x91
 712 0230 EC7C     		.sleb128 -404
 713 0232 0E       		.uleb128 0xe
 714 0233 85020000 		.4byte	.LASF38
 715 0237 01       		.byte	0x1
 716 0238 6F       		.byte	0x6f
 717 0239 91010000 		.4byte	0x191
 718 023d 03       		.uleb128 0x3
 719 023e 91       		.byte	0x91
 720 023f D07C     		.sleb128 -432
 721 0241 00       		.byte	0
 722 0242 0A       		.uleb128 0xa
 723 0243 AB000000 		.4byte	0xab
 724 0247 53020000 		.4byte	0x253
 725 024b 11       		.uleb128 0x11
 726 024c 9E000000 		.4byte	0x9e
 727 0250 0001     		.2byte	0x100
 728 0252 00       		.byte	0
 729 0253 0E       		.uleb128 0xe
 730 0254 7F010000 		.4byte	.LASF39
 731 0258 01       		.byte	0x1
 732 0259 05       		.byte	0x5
 733 025a 42020000 		.4byte	0x242
 734 025e 05       		.uleb128 0x5
 735 025f 03       		.byte	0x3
 736 0260 00000000 		.4byte	uart_chars
 737 0264 0E       		.uleb128 0xe
 738 0265 FD000000 		.4byte	.LASF40
 739 0269 01       		.byte	0x1
 740 026a 06       		.byte	0x6
 741 026b 81000000 		.4byte	0x81
 742 026f 05       		.uleb128 0x5
 743 0270 03       		.byte	0x3
 744 0271 01010000 		.4byte	num_chars
 745 0275 0E       		.uleb128 0xe
 746 0276 2E020000 		.4byte	.LASF41
 747 027a 01       		.byte	0x1
 748 027b 08       		.byte	0x8
 749 027c B2000000 		.4byte	0xb2
 750 0280 05       		.uleb128 0x5
 751 0281 03       		.byte	0x3
 752 0282 00000000 		.4byte	line
 753 0286 0E       		.uleb128 0xe
 754 0287 23010000 		.4byte	.LASF42
 755 028b 01       		.byte	0x1
 756 028c 0B       		.byte	0xb
 757 028d B2000000 		.4byte	0xb2
 758 0291 05       		.uleb128 0x5
 759 0292 03       		.byte	0x3
 760 0293 04010000 		.4byte	match
 761 0297 0E       		.uleb128 0xe
 762 0298 6A020000 		.4byte	.LASF43
 763 029c 01       		.byte	0x1
 764 029d 0C       		.byte	0xc
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 17


 765 029e B2000000 		.4byte	0xb2
 766 02a2 05       		.uleb128 0x5
 767 02a3 03       		.byte	0x3
 768 02a4 08010000 		.4byte	pattern
 769 02a8 12       		.uleb128 0x12
 770 02a9 92010000 		.4byte	.LASF47
 771 02ad 07       		.byte	0x7
 772 02ae 1207     		.2byte	0x712
 773 02b0 B4020000 		.4byte	0x2b4
 774 02b4 13       		.uleb128 0x13
 775 02b5 8C000000 		.4byte	0x8c
 776 02b9 00       		.byte	0
 777              		.section	.debug_abbrev,"",%progbits
 778              	.Ldebug_abbrev0:
 779 0000 01       		.uleb128 0x1
 780 0001 11       		.uleb128 0x11
 781 0002 01       		.byte	0x1
 782 0003 25       		.uleb128 0x25
 783 0004 0E       		.uleb128 0xe
 784 0005 13       		.uleb128 0x13
 785 0006 0B       		.uleb128 0xb
 786 0007 03       		.uleb128 0x3
 787 0008 0E       		.uleb128 0xe
 788 0009 1B       		.uleb128 0x1b
 789 000a 0E       		.uleb128 0xe
 790 000b 55       		.uleb128 0x55
 791 000c 17       		.uleb128 0x17
 792 000d 11       		.uleb128 0x11
 793 000e 01       		.uleb128 0x1
 794 000f 10       		.uleb128 0x10
 795 0010 17       		.uleb128 0x17
 796 0011 00       		.byte	0
 797 0012 00       		.byte	0
 798 0013 02       		.uleb128 0x2
 799 0014 24       		.uleb128 0x24
 800 0015 00       		.byte	0
 801 0016 0B       		.uleb128 0xb
 802 0017 0B       		.uleb128 0xb
 803 0018 3E       		.uleb128 0x3e
 804 0019 0B       		.uleb128 0xb
 805 001a 03       		.uleb128 0x3
 806 001b 0E       		.uleb128 0xe
 807 001c 00       		.byte	0
 808 001d 00       		.byte	0
 809 001e 03       		.uleb128 0x3
 810 001f 16       		.uleb128 0x16
 811 0020 00       		.byte	0
 812 0021 03       		.uleb128 0x3
 813 0022 0E       		.uleb128 0xe
 814 0023 3A       		.uleb128 0x3a
 815 0024 0B       		.uleb128 0xb
 816 0025 3B       		.uleb128 0x3b
 817 0026 0B       		.uleb128 0xb
 818 0027 49       		.uleb128 0x49
 819 0028 13       		.uleb128 0x13
 820 0029 00       		.byte	0
 821 002a 00       		.byte	0
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 18


 822 002b 04       		.uleb128 0x4
 823 002c 24       		.uleb128 0x24
 824 002d 00       		.byte	0
 825 002e 0B       		.uleb128 0xb
 826 002f 0B       		.uleb128 0xb
 827 0030 3E       		.uleb128 0x3e
 828 0031 0B       		.uleb128 0xb
 829 0032 03       		.uleb128 0x3
 830 0033 08       		.uleb128 0x8
 831 0034 00       		.byte	0
 832 0035 00       		.byte	0
 833 0036 05       		.uleb128 0x5
 834 0037 0F       		.uleb128 0xf
 835 0038 00       		.byte	0
 836 0039 0B       		.uleb128 0xb
 837 003a 0B       		.uleb128 0xb
 838 003b 49       		.uleb128 0x49
 839 003c 13       		.uleb128 0x13
 840 003d 00       		.byte	0
 841 003e 00       		.byte	0
 842 003f 06       		.uleb128 0x6
 843 0040 26       		.uleb128 0x26
 844 0041 00       		.byte	0
 845 0042 49       		.uleb128 0x49
 846 0043 13       		.uleb128 0x13
 847 0044 00       		.byte	0
 848 0045 00       		.byte	0
 849 0046 07       		.uleb128 0x7
 850 0047 16       		.uleb128 0x16
 851 0048 00       		.byte	0
 852 0049 03       		.uleb128 0x3
 853 004a 0E       		.uleb128 0xe
 854 004b 3A       		.uleb128 0x3a
 855 004c 0B       		.uleb128 0xb
 856 004d 3B       		.uleb128 0x3b
 857 004e 05       		.uleb128 0x5
 858 004f 49       		.uleb128 0x49
 859 0050 13       		.uleb128 0x13
 860 0051 00       		.byte	0
 861 0052 00       		.byte	0
 862 0053 08       		.uleb128 0x8
 863 0054 13       		.uleb128 0x13
 864 0055 01       		.byte	0x1
 865 0056 0B       		.uleb128 0xb
 866 0057 05       		.uleb128 0x5
 867 0058 3A       		.uleb128 0x3a
 868 0059 0B       		.uleb128 0xb
 869 005a 3B       		.uleb128 0x3b
 870 005b 0B       		.uleb128 0xb
 871 005c 01       		.uleb128 0x1
 872 005d 13       		.uleb128 0x13
 873 005e 00       		.byte	0
 874 005f 00       		.byte	0
 875 0060 09       		.uleb128 0x9
 876 0061 0D       		.uleb128 0xd
 877 0062 00       		.byte	0
 878 0063 03       		.uleb128 0x3
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 19


 879 0064 0E       		.uleb128 0xe
 880 0065 3A       		.uleb128 0x3a
 881 0066 0B       		.uleb128 0xb
 882 0067 3B       		.uleb128 0x3b
 883 0068 0B       		.uleb128 0xb
 884 0069 49       		.uleb128 0x49
 885 006a 13       		.uleb128 0x13
 886 006b 38       		.uleb128 0x38
 887 006c 0B       		.uleb128 0xb
 888 006d 00       		.byte	0
 889 006e 00       		.byte	0
 890 006f 0A       		.uleb128 0xa
 891 0070 01       		.uleb128 0x1
 892 0071 01       		.byte	0x1
 893 0072 49       		.uleb128 0x49
 894 0073 13       		.uleb128 0x13
 895 0074 01       		.uleb128 0x1
 896 0075 13       		.uleb128 0x13
 897 0076 00       		.byte	0
 898 0077 00       		.byte	0
 899 0078 0B       		.uleb128 0xb
 900 0079 21       		.uleb128 0x21
 901 007a 00       		.byte	0
 902 007b 49       		.uleb128 0x49
 903 007c 13       		.uleb128 0x13
 904 007d 2F       		.uleb128 0x2f
 905 007e 0B       		.uleb128 0xb
 906 007f 00       		.byte	0
 907 0080 00       		.byte	0
 908 0081 0C       		.uleb128 0xc
 909 0082 13       		.uleb128 0x13
 910 0083 01       		.byte	0x1
 911 0084 0B       		.uleb128 0xb
 912 0085 0B       		.uleb128 0xb
 913 0086 3A       		.uleb128 0x3a
 914 0087 0B       		.uleb128 0xb
 915 0088 3B       		.uleb128 0x3b
 916 0089 0B       		.uleb128 0xb
 917 008a 01       		.uleb128 0x1
 918 008b 13       		.uleb128 0x13
 919 008c 00       		.byte	0
 920 008d 00       		.byte	0
 921 008e 0D       		.uleb128 0xd
 922 008f 2E       		.uleb128 0x2e
 923 0090 01       		.byte	0x1
 924 0091 3F       		.uleb128 0x3f
 925 0092 19       		.uleb128 0x19
 926 0093 03       		.uleb128 0x3
 927 0094 0E       		.uleb128 0xe
 928 0095 3A       		.uleb128 0x3a
 929 0096 0B       		.uleb128 0xb
 930 0097 3B       		.uleb128 0x3b
 931 0098 0B       		.uleb128 0xb
 932 0099 27       		.uleb128 0x27
 933 009a 19       		.uleb128 0x19
 934 009b 11       		.uleb128 0x11
 935 009c 01       		.uleb128 0x1
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 20


 936 009d 12       		.uleb128 0x12
 937 009e 06       		.uleb128 0x6
 938 009f 40       		.uleb128 0x40
 939 00a0 18       		.uleb128 0x18
 940 00a1 9642     		.uleb128 0x2116
 941 00a3 19       		.uleb128 0x19
 942 00a4 01       		.uleb128 0x1
 943 00a5 13       		.uleb128 0x13
 944 00a6 00       		.byte	0
 945 00a7 00       		.byte	0
 946 00a8 0E       		.uleb128 0xe
 947 00a9 34       		.uleb128 0x34
 948 00aa 00       		.byte	0
 949 00ab 03       		.uleb128 0x3
 950 00ac 0E       		.uleb128 0xe
 951 00ad 3A       		.uleb128 0x3a
 952 00ae 0B       		.uleb128 0xb
 953 00af 3B       		.uleb128 0x3b
 954 00b0 0B       		.uleb128 0xb
 955 00b1 49       		.uleb128 0x49
 956 00b2 13       		.uleb128 0x13
 957 00b3 02       		.uleb128 0x2
 958 00b4 18       		.uleb128 0x18
 959 00b5 00       		.byte	0
 960 00b6 00       		.byte	0
 961 00b7 0F       		.uleb128 0xf
 962 00b8 2E       		.uleb128 0x2e
 963 00b9 01       		.byte	0x1
 964 00ba 3F       		.uleb128 0x3f
 965 00bb 19       		.uleb128 0x19
 966 00bc 03       		.uleb128 0x3
 967 00bd 0E       		.uleb128 0xe
 968 00be 3A       		.uleb128 0x3a
 969 00bf 0B       		.uleb128 0xb
 970 00c0 3B       		.uleb128 0x3b
 971 00c1 0B       		.uleb128 0xb
 972 00c2 49       		.uleb128 0x49
 973 00c3 13       		.uleb128 0x13
 974 00c4 11       		.uleb128 0x11
 975 00c5 01       		.uleb128 0x1
 976 00c6 12       		.uleb128 0x12
 977 00c7 06       		.uleb128 0x6
 978 00c8 40       		.uleb128 0x40
 979 00c9 18       		.uleb128 0x18
 980 00ca 9642     		.uleb128 0x2116
 981 00cc 19       		.uleb128 0x19
 982 00cd 01       		.uleb128 0x1
 983 00ce 13       		.uleb128 0x13
 984 00cf 00       		.byte	0
 985 00d0 00       		.byte	0
 986 00d1 10       		.uleb128 0x10
 987 00d2 0B       		.uleb128 0xb
 988 00d3 01       		.byte	0x1
 989 00d4 55       		.uleb128 0x55
 990 00d5 17       		.uleb128 0x17
 991 00d6 00       		.byte	0
 992 00d7 00       		.byte	0
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 21


 993 00d8 11       		.uleb128 0x11
 994 00d9 21       		.uleb128 0x21
 995 00da 00       		.byte	0
 996 00db 49       		.uleb128 0x49
 997 00dc 13       		.uleb128 0x13
 998 00dd 2F       		.uleb128 0x2f
 999 00de 05       		.uleb128 0x5
 1000 00df 00       		.byte	0
 1001 00e0 00       		.byte	0
 1002 00e1 12       		.uleb128 0x12
 1003 00e2 34       		.uleb128 0x34
 1004 00e3 00       		.byte	0
 1005 00e4 03       		.uleb128 0x3
 1006 00e5 0E       		.uleb128 0xe
 1007 00e6 3A       		.uleb128 0x3a
 1008 00e7 0B       		.uleb128 0xb
 1009 00e8 3B       		.uleb128 0x3b
 1010 00e9 05       		.uleb128 0x5
 1011 00ea 49       		.uleb128 0x49
 1012 00eb 13       		.uleb128 0x13
 1013 00ec 3F       		.uleb128 0x3f
 1014 00ed 19       		.uleb128 0x19
 1015 00ee 3C       		.uleb128 0x3c
 1016 00ef 19       		.uleb128 0x19
 1017 00f0 00       		.byte	0
 1018 00f1 00       		.byte	0
 1019 00f2 13       		.uleb128 0x13
 1020 00f3 35       		.uleb128 0x35
 1021 00f4 00       		.byte	0
 1022 00f5 49       		.uleb128 0x49
 1023 00f6 13       		.uleb128 0x13
 1024 00f7 00       		.byte	0
 1025 00f8 00       		.byte	0
 1026 00f9 00       		.byte	0
 1027              		.section	.debug_aranges,"",%progbits
 1028 0000 2C000000 		.4byte	0x2c
 1029 0004 0200     		.2byte	0x2
 1030 0006 00000000 		.4byte	.Ldebug_info0
 1031 000a 04       		.byte	0x4
 1032 000b 00       		.byte	0
 1033 000c 0000     		.2byte	0
 1034 000e 0000     		.2byte	0
 1035 0010 00000000 		.4byte	.LFB64
 1036 0014 70000000 		.4byte	.LFE64-.LFB64
 1037 0018 00000000 		.4byte	.LFB65
 1038 001c 1C010000 		.4byte	.LFE65-.LFB65
 1039 0020 00000000 		.4byte	.LFB66
 1040 0024 D0000000 		.4byte	.LFE66-.LFB66
 1041 0028 00000000 		.4byte	0
 1042 002c 00000000 		.4byte	0
 1043              		.section	.debug_ranges,"",%progbits
 1044              	.Ldebug_ranges0:
 1045 0000 70000000 		.4byte	.LBB2
 1046 0004 C0000000 		.4byte	.LBE2
 1047 0008 D2000000 		.4byte	.LBB3
 1048 000c D4000000 		.4byte	.LBE3
 1049 0010 00000000 		.4byte	0
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 22


 1050 0014 00000000 		.4byte	0
 1051 0018 00000000 		.4byte	.LFB64
 1052 001c 70000000 		.4byte	.LFE64
 1053 0020 00000000 		.4byte	.LFB65
 1054 0024 1C010000 		.4byte	.LFE65
 1055 0028 00000000 		.4byte	.LFB66
 1056 002c D0000000 		.4byte	.LFE66
 1057 0030 00000000 		.4byte	0
 1058 0034 00000000 		.4byte	0
 1059              		.section	.debug_line,"",%progbits
 1060              	.Ldebug_line0:
 1061 0000 FB010000 		.section	.debug_str,"MS",%progbits,1
 1061      02007E01 
 1061      00000201 
 1061      FB0E0D00 
 1061      01010101 
 1062              	.LASF4:
 1063 0000 5F5F7569 		.ascii	"__uint8_t\000"
 1063      6E74385F 
 1063      7400
 1064              	.LASF44:
 1065 000a 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 1065      43313120 
 1065      352E342E 
 1065      31203230 
 1065      31363036 
 1066 003d 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 1066      20726576 
 1066      6973696F 
 1066      6E203233 
 1066      37373135 
 1067 0070 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 1067      66756E63 
 1067      74696F6E 
 1067      2D736563 
 1067      74696F6E 
 1068              	.LASF5:
 1069 0098 5F5F696E 		.ascii	"__int32_t\000"
 1069      7433325F 
 1069      7400
 1070              	.LASF24:
 1071 00a2 74657374 		.ascii	"test_t\000"
 1071      5F7400
 1072              	.LASF6:
 1073 00a9 6C6F6E67 		.ascii	"long int\000"
 1073      20696E74 
 1073      00
 1074              	.LASF25:
 1075 00b2 616C6C5F 		.ascii	"all_level_readings\000"
 1075      6C657665 
 1075      6C5F7265 
 1075      6164696E 
 1075      677300
 1076              	.LASF27:
 1077 00c5 6E756D5F 		.ascii	"num_valid_readings\000"
 1077      76616C69 
 1077      645F7265 
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 23


 1077      6164696E 
 1077      677300
 1078              	.LASF31:
 1079 00d8 646F776E 		.ascii	"downstream_level_sensor_take_reading\000"
 1079      73747265 
 1079      616D5F6C 
 1079      6576656C 
 1079      5F73656E 
 1080              	.LASF40:
 1081 00fd 6E756D5F 		.ascii	"num_chars\000"
 1081      63686172 
 1081      7300
 1082              	.LASF35:
 1083 0107 72656164 		.ascii	"reading\000"
 1083      696E6700 
 1084              	.LASF17:
 1085 010f 666C6F61 		.ascii	"float\000"
 1085      7400
 1086              	.LASF1:
 1087 0115 756E7369 		.ascii	"unsigned char\000"
 1087      676E6564 
 1087      20636861 
 1087      7200
 1088              	.LASF42:
 1089 0123 6D617463 		.ascii	"match\000"
 1089      6800
 1090              	.LASF30:
 1091 0129 446F776E 		.ascii	"Downstream_Level_Sensor_ISR\000"
 1091      73747265 
 1091      616D5F4C 
 1091      6576656C 
 1091      5F53656E 
 1092              	.LASF20:
 1093 0145 696E7431 		.ascii	"int16\000"
 1093      3600
 1094              	.LASF7:
 1095 014b 6C6F6E67 		.ascii	"long unsigned int\000"
 1095      20756E73 
 1095      69676E65 
 1095      6420696E 
 1095      7400
 1096              	.LASF3:
 1097 015d 73686F72 		.ascii	"short unsigned int\000"
 1097      7420756E 
 1097      7369676E 
 1097      65642069 
 1097      6E7400
 1098              	.LASF29:
 1099 0170 6C657665 		.ascii	"level_sensor_t\000"
 1099      6C5F7365 
 1099      6E736F72 
 1099      5F7400
 1100              	.LASF39:
 1101 017f 75617274 		.ascii	"uart_chars\000"
 1101      5F636861 
 1101      727300
 1102              	.LASF32:
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 24


 1103 018a 72785F63 		.ascii	"rx_char\000"
 1103      68617200 
 1104              	.LASF47:
 1105 0192 49544D5F 		.ascii	"ITM_RxBuffer\000"
 1105      52784275 
 1105      66666572 
 1105      00
 1106              	.LASF16:
 1107 019f 646F7562 		.ascii	"double\000"
 1107      6C6500
 1108              	.LASF46:
 1109 01a6 433A5C55 		.ascii	"C:\\Users\\dantz\\Documents\\GitHub\\notoriOS\\noto"
 1109      73657273 
 1109      5C64616E 
 1109      747A5C44 
 1109      6F63756D 
 1110 01d3 72694F53 		.ascii	"riOS.cydsn\000"
 1110      2E637964 
 1110      736E00
 1111              	.LASF2:
 1112 01de 73686F72 		.ascii	"short int\000"
 1112      7420696E 
 1112      7400
 1113              	.LASF26:
 1114 01e8 6C657665 		.ascii	"level_reading\000"
 1114      6C5F7265 
 1114      6164696E 
 1114      6700
 1115              	.LASF19:
 1116 01f6 75696E74 		.ascii	"uint16\000"
 1116      313600
 1117              	.LASF37:
 1118 01fd 74657374 		.ascii	"test\000"
 1118      00
 1119              	.LASF10:
 1120 0202 756E7369 		.ascii	"unsigned int\000"
 1120      676E6564 
 1120      20696E74 
 1120      00
 1121              	.LASF9:
 1122 020f 6C6F6E67 		.ascii	"long long unsigned int\000"
 1122      206C6F6E 
 1122      6720756E 
 1122      7369676E 
 1122      65642069 
 1123              	.LASF11:
 1124 0226 75696E74 		.ascii	"uint8_t\000"
 1124      385F7400 
 1125              	.LASF41:
 1126 022e 6C696E65 		.ascii	"line\000"
 1126      00
 1127              	.LASF23:
 1128 0233 72656173 		.ascii	"reason\000"
 1128      6F6E00
 1129              	.LASF12:
 1130 023a 696E7433 		.ascii	"int32_t\000"
 1130      325F7400 
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 25


 1131              	.LASF14:
 1132 0242 73697A65 		.ascii	"sizetype\000"
 1132      74797065 
 1132      00
 1133              	.LASF33:
 1134 024b 446F776E 		.ascii	"Downstream_Level_Sensor_output\000"
 1134      73747265 
 1134      616D5F4C 
 1134      6576656C 
 1134      5F53656E 
 1135              	.LASF43:
 1136 026a 70617474 		.ascii	"pattern\000"
 1136      65726E00 
 1137              	.LASF8:
 1138 0272 6C6F6E67 		.ascii	"long long int\000"
 1138      206C6F6E 
 1138      6720696E 
 1138      7400
 1139              	.LASF15:
 1140 0280 63686172 		.ascii	"char\000"
 1140      00
 1141              	.LASF38:
 1142 0285 73656E73 		.ascii	"sensor\000"
 1142      6F7200
 1143              	.LASF36:
 1144 028c 646F776E 		.ascii	"downstream_level_sensor_test\000"
 1144      73747265 
 1144      616D5F6C 
 1144      6576656C 
 1144      5F73656E 
 1145              	.LASF45:
 1146 02a9 646F776E 		.ascii	"downstream_level_sensor.c\000"
 1146      73747265 
 1146      616D5F6C 
 1146      6576656C 
 1146      5F73656E 
 1147              	.LASF18:
 1148 02c3 75696E74 		.ascii	"uint8\000"
 1148      3800
 1149              	.LASF21:
 1150 02c9 74657374 		.ascii	"test_name\000"
 1150      5F6E616D 
 1150      6500
 1151              	.LASF34:
 1152 02d3 746F6B65 		.ascii	"token\000"
 1152      6E00
 1153              	.LASF22:
 1154 02d9 73746174 		.ascii	"status\000"
 1154      757300
 1155              	.LASF13:
 1156 02e0 6C6F6E67 		.ascii	"long double\000"
 1156      20646F75 
 1156      626C6500 
 1157              	.LASF0:
 1158 02ec 7369676E 		.ascii	"signed char\000"
 1158      65642063 
 1158      68617200 
ARM GAS  C:\Users\dantz\AppData\Local\Temp\ccoL9zwM.s 			page 26


 1159              	.LASF28:
 1160 02f8 6E756D5F 		.ascii	"num_invalid_readings\000"
 1160      696E7661 
 1160      6C69645F 
 1160      72656164 
 1160      696E6773 
 1161              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
